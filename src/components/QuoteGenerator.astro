---
import { Image } from 'astro:assets';
import marcusImg from '../assets/images/marcus.png';
import epictetusImg from '../assets/images/epictetus.png';
import senecaImg from '../assets/images/seneca.png';

const philosophers = [
  { id: 'marcus', name: 'Marcus Aurelius', title: 'the Emperor', image: marcusImg, glow: 'rgba(255, 0, 255, 0.5)' },
  { id: 'epictetus', name: 'Epictetus', title: 'the Teacher', image: epictetusImg, glow: 'rgba(0, 242, 255, 0.4)' },
  { id: 'seneca', name: 'Seneca', title: 'the Advisor', image: senecaImg, glow: 'rgba(255, 255, 0, 0.3)' }
];
---

<div class="h-screen w-full overflow-y-scroll snap-y snap-mandatory scroll-smooth no-scrollbar" id="stoic-scroller">
  {philosophers.map((phil, index) => (
    <section class="h-screen w-full flex flex-col items-center justify-center snap-start relative overflow-hidden px-6 pb-20" data-philosopher={phil.id}>

      <div class="bust-trigger cursor-pointer transition-all duration-700 active:scale-95 group z-20">
        <Image
          src={phil.image}
          alt={phil.name}
          class="w-56 md:w-72 h-auto transition-transform duration-700 group-hover:scale-105"
          style={`filter: drop-shadow(0 0 15px ${phil.glow})`}
          width={288}
        />
      </div>

      <div class="z-20 text-center mt-4">
        <p class="text-[10px] uppercase tracking-[0.6em] text-slate-900/40 font-black mb-3">{phil.name}</p>

        <!-- Typography-First Navigation - always visible -->
        <nav class="flex items-center justify-center gap-1.5 text-[11px] font-medium text-slate-900/70 uppercase tracking-widest leading-none">
          <select data-nav="work" class="nav-select nav-bold">
            <option>Work</option>
          </select>
          <span class="nav-dot opacity-30 px-1">•</span>
          <select data-nav="book" class="nav-select nav-bold">
            <option>Book</option>
          </select>
          <span class="book-dot opacity-30 px-1">•</span>
          <select data-nav="verse" class="nav-select nav-bold">
            <option>Verse</option>
          </select>
          <span class="trans-dot opacity-30 px-1 hidden">•</span>
          <select data-nav="translation" class="nav-select nav-bold hidden">
            <option>Translation</option>
          </select>
        </nav>
      </div>

      <div class="relative w-full max-w-3xl mt-8 group/quote z-20 px-4">
        <span class="absolute -top-12 -left-4 text-8xl font-serif text-slate-900/5 select-none pointer-events-none">"</span>
        <span class="absolute -bottom-12 -right-4 text-8xl font-serif text-slate-900/5 select-none pointer-events-none">"</span>

        <button class="copy-btn absolute right-0 -top-6 opacity-0 transition-opacity p-2 text-slate-900/20 hover:text-slate-900" title="Copy Quote" aria-label="Copy quote to clipboard">
          <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round"><rect x="9" y="9" width="13" height="13" rx="2" ry="2"></rect><path d="M5 15H4a2 2 0 0 1-2-2V4a2 2 0 0 1 2-2h9a2 2 0 0 1 2 2v1"></path></svg>
        </button>

        <div class="quote-area flex flex-col items-center overflow-y-auto max-h-[28vh] md:max-h-[32vh] px-2 invisible-scrollbar">
          <p class="quote-text text-xl md:text-3xl text-slate-900 font-light tracking-tight leading-relaxed md:leading-relaxed text-center"></p>
        </div>
      </div>

      <div class="scroll-hint absolute bottom-6 text-slate-900/30 text-[10px] animate-bounce uppercase tracking-widest font-bold z-20">
        {index === 0 ? '↓ scroll' : index === philosophers.length - 1 ? '↑ scroll' : '↑↓'}
      </div>
    </section>
  ))}
</div>

<style is:global>
  .no-scrollbar::-webkit-scrollbar { display: none; }
  .no-scrollbar { -ms-overflow-style: none; scrollbar-width: none; }
  .invisible-scrollbar::-webkit-scrollbar { width: 0; }

  /* Smooth scroll behavior */
  #stoic-scroller {
    scroll-behavior: smooth;
    -webkit-overflow-scrolling: touch;
    scroll-snap-type: y mandatory;
  }

  /* Section snap and transition */
  section[data-philosopher] {
    scroll-snap-align: start;
    scroll-snap-stop: always;
  }

  /* Typography-first navigation selects */
  .nav-select {
    appearance: none;
    -webkit-appearance: none;
    -moz-appearance: none;
    background: transparent;
    border: none;
    outline: none;
    cursor: pointer;
    text-align: center;
    text-align-last: center;
    padding: 0;
    margin: 0;
    font: inherit;
    color: inherit;
  }

  .nav-select:focus { outline: none; }

  /* Bold style for active selections */
  .nav-bold {
    color: rgba(15, 23, 42, 0.8);
    font-weight: 700;
    transition: color 0.2s ease;
  }

  .nav-bold:hover {
    color: rgba(15, 23, 42, 1);
  }

  /* Quote area with reveal animation */
  .quote-area {
    transition: opacity 0.4s ease-in-out, transform 0.4s ease-out;
  }

  .quote-area.revealing {
    opacity: 0;
    transform: translateY(8px);
  }

  .quote-area.revealed {
    opacity: 1;
    transform: translateY(0);
  }

  /* Quote text cinematic reveal */
  .quote-text {
    transition: opacity 0.5s ease-out, transform 0.5s ease-out;
  }

  .quote-text.fade-out {
    opacity: 0;
    transform: scale(0.98);
  }

  .quote-text.fade-in {
    opacity: 1;
    transform: scale(1);
  }

  @media (hover: hover) {
    .group\/quote:hover .copy-btn { opacity: 1; }
  }
  .copy-btn.visible { opacity: 0.6 !important; }
</style>

<script>
  // State management (work is null for single-work philosophers like Marcus)
  const state = {
    marcus: { work: null, book: 1, verse: 1, translation: 'english' },
    epictetus: { work: null, book: null, verse: 1, translation: 'english' },
    seneca: { work: null, book: null, verse: 1, translation: 'english' }
  };

  const dataStore = {};
  const isTouch = window.matchMedia("(pointer: coarse)").matches;

  const sources = {
    marcus: '/api/stoa/marcus',
    epictetus: '/api/stoa/epictetus',
    seneca: '/api/stoa/seneca'
  };

  // Load data with schema detection (backward compatible)
  async function loadData(philId) {
    if (dataStore[philId]) return dataStore[philId];

    try {
      const res = await fetch(sources[philId]);
      const data = await res.json();

      // Phase 1: Detect schema version
      dataStore[philId] = {
        entries: data.entries || data,
        metadata: data.metadata || {
          translations: { english: 'Default' },
          defaultTranslation: 'english'
        }
      };

      return dataStore[philId];
    } catch (e) {
      console.warn(`Load error: ${philId}`);
      return null;
    }
  }

  // Numeric sort helper
  function numericSort(a, b) {
    const numA = parseInt(a, 10);
    const numB = parseInt(b, 10);
    if (!isNaN(numA) && !isNaN(numB)) return numA - numB;
    return String(a).localeCompare(String(b));
  }

  // Update navigation selectors
  function updateSelectors(section, store, philState, philId) {
    const { entries, metadata } = store;
    const workSel = section.querySelector('[data-nav="work"]');
    const workDot = section.querySelector('.nav-dot');
    const bookSel = section.querySelector('[data-nav="book"]');
    const bookDot = section.querySelector('.book-dot');
    const verseSel = section.querySelector('[data-nav="verse"]');
    const transSel = section.querySelector('[data-nav="translation"]');

    // Always show Work selector - API now provides defaults for all philosophers
    const works = metadata.works || ['Works'];
    workSel.style.display = 'inline-block';
    workDot.style.display = 'inline';
    workSel.innerHTML = works.map(w =>
      `<option value="${w}" ${w == philState.work ? 'selected' : ''}>${w}</option>`
    ).join('');

    // Set default work if not set
    if (!philState.work) philState.work = works[0];

    // Filter entries by current work (for multi-work philosophers with work field)
    let filteredEntries = entries;
    const hasWorkField = entries.some(e => e.work);
    if (hasWorkField && philState.work) {
      filteredEntries = entries.filter(e => e.work === philState.work);
    }

    // Get unique books with numeric sort
    const books = [...new Set(filteredEntries.map(e => e.book).filter(Boolean))].sort(numericSort);

    if (books.length > 0) {
      bookSel.style.display = 'inline-block';
      if (bookDot) bookDot.style.display = 'inline';
      bookSel.innerHTML = books.map(b => {
        const label = typeof b === 'number' || !isNaN(parseInt(b)) ? `Book ${b}` : b;
        return `<option value="${b}" ${b == philState.book ? 'selected' : ''}>${label}</option>`;
      }).join('');

      // Set default book if not set or invalid
      if (!philState.book || !books.includes(String(philState.book)) && !books.includes(philState.book)) {
        philState.book = books[0];
      }
    } else {
      // No books (e.g., Enchiridion chapters directly)
      bookSel.style.display = 'none';
      if (bookDot) bookDot.style.display = 'none';
      philState.book = null;
    }

    // Get verses for current book/work with numeric sort
    let currentEntries = filteredEntries;
    if (philState.book) {
      currentEntries = filteredEntries.filter(e => String(e.book) === String(philState.book));
    }
    const verses = [...new Set(currentEntries.map(e => e.verse || e.chapter || e.letter).filter(Boolean))].sort(numericSort);

    verseSel.innerHTML = verses.map(v =>
      `<option value="${v}" ${v == philState.verse ? 'selected' : ''}>${v}</option>`
    ).join('');

    // Set default verse if not set or invalid
    if (!philState.verse || !verses.includes(String(philState.verse)) && !verses.includes(philState.verse)) {
      philState.verse = verses[0];
    }

    // Translations
    const translations = metadata.translations;
    const transKeys = Object.keys(translations);
    const transDot = section.querySelector('.trans-dot');

    if (transKeys.length > 1) {
      transSel.style.display = 'inline-block';
      if (transDot) transDot.style.display = 'inline';
      transSel.innerHTML = transKeys.map(key => {
        const label = translations[key].split(' ')[0];
        return `<option value="${key}" ${key == philState.translation ? 'selected' : ''}>${label}</option>`;
      }).join('');
    } else {
      transSel.style.display = 'none';
      if (transDot) transDot.style.display = 'none';
    }
  }

  // Format source citation
  function formatSource(entry, philId) {
    const book = entry.book || entry.work;
    const verse = entry.verse || entry.chapter || entry.letter;

    switch (philId) {
      case 'marcus':
        return `Book ${book} • Verse ${verse}`;
      case 'epictetus':
        return `${entry.work || 'Discourses'} • ${verse}`;
      case 'seneca':
        return `${entry.work || 'Letters'} • ${entry.letter ? `Letter ${entry.letter}` : verse}`;
      default:
        return `${book} • ${verse}`;
    }
  }

  // Render quote
  async function render(philId, random = false) {
    const section = document.querySelector(`section[data-philosopher="${philId}"]`);
    const store = await loadData(philId);
    if (!store) return;

    const { entries, metadata } = store;
    const philState = state[philId];
    const quoteArea = section.querySelector('.quote-area');
    const textEl = section.querySelector('.quote-text');
    const copyBtn = section.querySelector('.copy-btn');

    // Initialize work if multi-work philosopher
    if (metadata.works && metadata.works.length > 1 && !philState.work) {
      philState.work = metadata.works[0];
    }

    // Filter entries by current work
    let filteredEntries = entries;
    if (philState.work) {
      filteredEntries = entries.filter(e => e.work === philState.work);
    }

    let entry;

    if (random) {
      // Shuffle: pick random entry from filtered set
      entry = filteredEntries[Math.floor(Math.random() * filteredEntries.length)];
      if (entry.work) philState.work = entry.work;
      philState.book = entry.book || null;
      philState.verse = entry.verse || entry.chapter || entry.letter;
    } else {
      // Navigate: find specific entry
      entry = filteredEntries.find(e => {
        const bookMatch = !philState.book || String(e.book) === String(philState.book);
        const verseMatch = String(e.verse || e.chapter || e.letter) === String(philState.verse);
        return bookMatch && verseMatch;
      }) || filteredEntries[0];
    }

    // Cinematic fade out
    textEl.classList.add('fade-out');
    textEl.classList.remove('fade-in');
    quoteArea.classList.add('revealing');
    quoteArea.classList.remove('revealed');
    if (isTouch) copyBtn?.classList.remove('visible');

    setTimeout(() => {
      // Get text with translation fallback
      const text = entry.text?.[philState.translation] || entry.english || entry.text || "Selection not available.";
      textEl.innerText = text;

      // Update selectors first
      updateSelectors(section, store, philState, philId);

      // Cinematic fade in
      requestAnimationFrame(() => {
        textEl.classList.remove('fade-out');
        textEl.classList.add('fade-in');
        quoteArea.classList.remove('revealing');
        quoteArea.classList.add('revealed');
        quoteArea.scrollTop = 0;

        if (isTouch) copyBtn?.classList.add('visible');
      });
    }, 350);
  }

  // Copy icons
  const copyIcon = '<svg xmlns="http://www.w3.org/2000/svg" width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round"><rect x="9" y="9" width="13" height="13" rx="2" ry="2"></rect><path d="M5 15H4a2 2 0 0 1-2-2V4a2 2 0 0 1 2-2h9a2 2 0 0 1 2 2v1"></path></svg>';
  const checkIcon = '<svg xmlns="http://www.w3.org/2000/svg" width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="#0ea5e9" stroke-width="2.5" stroke-linecap="round" stroke-linejoin="round"><polyline points="20 6 9 17 4 12"></polyline></svg>';

  // Initialize each section
  document.querySelectorAll('section').forEach(section => {
    const philId = section.getAttribute('data-philosopher');

    // Bust click = Shuffle
    section.querySelector('.bust-trigger')?.addEventListener('click', () => render(philId, true));

    // Navigation selects
    section.querySelectorAll('.nav-select').forEach(select => {
      select.addEventListener('change', (e) => {
        const navType = e.target.dataset.nav;
        const value = e.target.value;

        if (navType === 'work') {
          state[philId].work = value;
          state[philId].book = null; // Reset book when work changes
          state[philId].verse = null; // Reset verse when work changes
        } else if (navType === 'book') {
          state[philId].book = isNaN(value) ? value : parseInt(value);
          state[philId].verse = null; // Reset verse when book changes
        } else if (navType === 'verse') {
          state[philId].verse = isNaN(value) ? value : parseInt(value);
        } else if (navType === 'translation') {
          state[philId].translation = value;
        }

        render(philId, false);
      });
    });

    // Copy button - construct source from navigation state
    const copyBtn = section.querySelector('.copy-btn');
    copyBtn?.addEventListener('click', async () => {
      const textEl = section.querySelector('.quote-text');
      const bookSel = section.querySelector('[data-nav="book"]');
      const verseSel = section.querySelector('[data-nav="verse"]');
      const workSel = section.querySelector('[data-nav="work"]');

      // Build source citation from current selections
      let source = '';
      if (workSel?.style.display !== 'none' && workSel?.value) {
        source += workSel.value + ' • ';
      }
      if (bookSel?.style.display !== 'none' && bookSel?.value) {
        source += bookSel.options[bookSel.selectedIndex]?.text + ' • ';
      }
      source += verseSel?.value || '';

      const content = `"${textEl.innerText}"\n— ${source}`;

      try {
        await navigator.clipboard.writeText(content);
        copyBtn.innerHTML = checkIcon;
        setTimeout(() => copyBtn.innerHTML = copyIcon, 2000);
      } catch (err) {
        console.error('Copy failed', err);
      }
    });
  });

  // Load initial data and render first philosopher
  render('marcus', true);

  // Parallax cloud effect on scroll
  const scroller = document.getElementById('stoic-scroller');
  const cloudsLayer = document.getElementById('clouds-layer');

  if (scroller && cloudsLayer) {
    let ticking = false;

    scroller.addEventListener('scroll', () => {
      if (!ticking) {
        requestAnimationFrame(() => {
          const scrollY = scroller.scrollTop;
          const maxScroll = scroller.scrollHeight - scroller.clientHeight;
          const scrollProgress = scrollY / maxScroll;

          // Parallax: clouds move at 20% of scroll speed, with subtle X drift
          const yOffset = scrollProgress * 30; // Max 30vh vertical shift
          const xOffset = Math.sin(scrollProgress * Math.PI) * 5; // Subtle horizontal wave

          cloudsLayer.style.transform = `translate(${xOffset}vw, ${yOffset}vh)`;

          ticking = false;
        });
        ticking = true;
      }
    });
  }
</script>
